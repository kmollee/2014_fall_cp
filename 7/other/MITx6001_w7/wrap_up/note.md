# Wrap up

## Wrapping it all up

- Where have you been?
    + What are the key topics from this course?
    + What are the key lessions to take from this course?
- Where are you headed?
    + How might you use the knowledge you have gained?

## What do computer scientist do?

- They think computationally
    + Abstractions, algorithms, automated execution
- Computational tinking will be a fundametal skill used by everyone in the world by the middle of the 21st Century
- Just like the [three r's](https://en.wikipedia.org/wiki/The_three_Rs): reading, writing and arithmetic.
    + Ubiquitous computing and computers will enable the spread of computational thinking as a fundamental skill for every well educated person

## Computational Thinking: the Process

- Identify or invent useful **absractions**(articulate and identify the key element inside of problem)
    + Suppressing detail, formulating interfaces
- Formulate solution to a problem as a **computational** **experiment** using abstactions
- Design and construct a **sufficiently efficent** implementation of experiment
- Validate experimental step(i.e., debug it)(run, test, unit test, test integrate whole, make sure it staisfies the different boundary condition or specil case)
- Run experiment
- Evaluate results of experiment(make sure the result make sense)
- Repeat as needed

## The three A's of computational thinking

- Abstaction
    + Choosing the right abstractions
    + Operating in terms of **multiple layer of abstraction** simultaneously
    + Defining the **relationships** the between layers
- Automation
    + Think in terms of mechanizing our abstractions
    + Mechanization is possible
        * Because we have precise and exacting notations and models
        * There is some "machine" that can interpret our notations
- Algorithms
    + Language for describing automated processes
    + Also allows abstraction of detail

## Examples of computational thinking

- How difficult is this problem and how best can I solve it?
    + Theoretical computer science gives precise meaning to these and related questions and their answers
- Thinking recursively
    + Reformulating a seemingly difficult problem into one which we knmow how to solve
    + Reduction, embedding, transformation, simulation

## Where have you been?

- Four major tpoics(and a lanaguae)
    + Leaning a lanaguae for expressing computations - `Python`
    + Learning aobut the process of writing and debugging aprogram - `Be systematic`
    + Learning to estimate computational `complexity`
    + Learning about the process of moving from a problem statement to a computational formulation of amethod for solving the problem - `Use abstraction`
    + learning a basic set of recipes - `Algorithms`

## Why Python?

- Relatively easy to learn and use
    + Simple syntax
    + Interpretive, which makes debugging easier(easier to read)
    + Don't have to worry about managing memory
- Modern
    + Supports currently stylish mode of programming, object-oriented
- Increasingly popular
    + Used in an increasing number of subjects at MIT and elsewhere
    + Increasing use in industry
    + Large and ever growing set of libraries

[programming language rank](http://www.tiobe.com/index.php/content/paperinfo/tpci/index.html)
[Top 10 Programming Languages 2014](http://spectrum.ieee.org/computing/software/top-10-programming-languages)

## Writing, testing and debugging programs

- Take it a step at time
    + Understand problem
    + Think about **overall structure** and **algorithms** independently of expression in programming language
    + Break into small parts
    + **Identify useful abstractions**(**data** and **functional**)
    + Code and unit test a part at a time
    + First functionality, then efficiency
    + Start with **pseudo code**
- Be systematic
    + When debugging, think scientific method(like binary search)
    + Ask yourself why program did what it did, not why it didn't do what you wanted it to do

## Estimating complexity

- Big O notation
    + Orders of growth
    + Exponetial, Polynomial, Linear, Log, Constant
- Recognizing common patterns of computation
- Learning to map problems into templates of solutions
    + Bisection search(log), tree search(exponetial),
- Some problems inherently expensive to solve

## From problem statement to computation

- Break the problem into a sries of smaller problems
- Try and relate problem to a problem you or somebody les have aleardy solved
    + e.g., can it be viewed as a knapsack problem? As an optimization problem?
- Think about what kind of output you might like to see
- Think about how to approximate solutions
    + Solve a simpler problem
    + Find a series of solutions that approaches(but may never reach) a perfect answer

## Algorithms

- Kinds of Algorithms
    + Exhaustive enumeration, Guess and check, Successive approximation, Greedy alorithms, Divide and conquer, Decision Trees
- Specific algorithms
    + e.g., Binary search, Merge sort, DFS, BFS

